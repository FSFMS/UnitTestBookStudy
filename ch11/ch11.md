# 단위테스트 안티 패턴

## 다루는 내용
```
* 비공개 메서드 단위 테스트
* 단위 테스트를 하기 위한 비공개 메서드 노출
* 테스트로 유출된 도메인 지식
* 구체 클래스 목 처리
```

## 비공개 메서드 단위 테스트
```
비공개 메서드를 단위테스트 해야할까? -> X
```

### 비공개 메서드와 테스트 취약성
* 비공개 메서드는 `식별할 수 있는 동작`이 아니기 때문에, 테스트를 진행하게 되면, 해당 원칙을 위반한다.
* 그래서 노출을 하게 된다면.. 구현 세부 사항과 결합되고, 리팩터링 내성이 떨어지게 된다.
* 따라서 직접적으로 테스트 하는 대신, 포괄적인 식별할수 있는 동작으로 간접적으로 테스트 하는것이 좋다. (통합 테스트..?)
### 비공개 메서드와 불필요한 커버리지
* 비공개 메서드가 복잡한경우에는, 시별할 수 있는 동작으로 테스트 하기에 충분하지 않을 수가 있다.
* 그럼에도 불구하고 식별할 수 있는 동작에 테스트 커버리지가 합리적이라고 하면 두가지 문제가 내포되어 있을 수 있다.
  * 죽은 코드 (테스트에서 벗어난 상태이며, 테스트 로직에 관계가 없는 코드)
  * 추상화 누락 (로직에 관계가 있는데 복잡한 경우라면, 추상화가 누락되어있다는 징후)
* 죽은 코드의 경우 제거를 하면 되고, 추상화가 필요한 경우 복잡한 비공개 메서드를 추상화시켜 분리하는게 좋다.
### 비공개 메서드 테스트가 타당한 경우
#### 코드의 공개 여부와 목적의 관계
||식별할 수 있는 동작|구현 세부 사항|
|---|---|---|
|공개|좋음|나쁨|
|비공개|해당 없음|좋음|

* 식별할 수 있는 동작을 공개로 하고, 구현 세부 사항을 비공개로 하면 API가 잘 설계되었다고 할 수 있다.
* 하지만 구현 세부 사항이 유출되면 캡슐화를 해치게 된다. (로직 코드가 public이 될 경우)
* 구현 세부사항은 비공개가 되면 `식별할 수 있는 동작`이 아니게 된다.
* `비공개 메서드의 테스트` 자체가 옳지 않다는게 아니라, 비공개 메서드가 `구현 세부 사항`의 영역이기 때문에 테스트를 안하는 것이다.
* 하지만, 대표적으로 ORM의 경우 생성자는 비공개 메서드인 경우가 있는데. 여기에 대한 로직들은 테스트가 필요하다.
  * 이런 경우라면 `식별할 수 있는 동작` 인 동시에 비공개 메서드 인데, 이는 DB 접근에 대한 특수성 때문이다.
  * 이런 경우에는 생성자를 공개한다고 해서 테스트가 쉽게 깨지지 않는다.

## 비공개 상태 노출
* 테스트 목적으로만 비공개 상태를 노출하는 경향이 있는데, 절대 좋지 않은 습관이다.
* 테스트는 제품 코드(=공개되는 코드)와 같은 방식으로 테스트를 진행하고 SUT와 상호작용을 한다.
* 테스트라고해서 따로 특권을 가지면 안된다.
* 즉, 블랙박스 테스트를 지향해야 한다.

## 테스트로 유출된 도메인 지식
* 도메인 지식을 테스트로 유출하는것은 흔한 안티패턴이며, 복잡한 알고리즘을 테스트할 때 자주 일어난다.
* 단순한 예를 들 때,
  * `twoSum`이라는 메서드를 테스트 할 때, 그것을 검증하기 위해 테스트 코드에 두 숫자를 더하는 로직을 쓴다고 하면
  * 결국 `twoSum`과 검증용 테스트 로직이 같아지게되고, 이것은 도메인 지식의 유출로 이어지는데.
  * 결국 테스트가 `구현 세부 사항`과 결합되는 안티패턴이고, 리팩터링 내성이 무의미해지게 된다.
* 이런 경우에는 결과값을 산출하는 로직을 짜서 넣지 말고, 예상 결과를 하드코딩해서 집어넣는 편이 좋다.
  * 이 결과값을 SUT가 아닌 다른 무언가를 이용해 계산하는게 중요하다.

## 코드 오염
* 코드오염 = 테스트에만 필요한 제품 코드를 추가
* 예시: 로깅을 저장하는데, 테스트시는 저장할 필요가 없는 경우, `if !test {` <- 이런 코드가 들어간 경우
* 이런 경우 유지비가 증가되어 생산성이 떨어지는 문제가 생긴다.
* 잠재적인 버그가 생겨나기도 한다.
* 되도록이면 인터페이스를 분리하여 사용하는게 좋다.
  
## 구체 클래스를 목으로 처리하기
* 구체 클래스를 목으로 처리하게 될 경우, 단일 책임 원칙을 위반하게 된다.
* 목 보다는, 도메인 로직 클래스와 통신 클래스로 분리하여 사용하는게 좋다.

## 시간 처리하기
* 실제 제품에서, 시간에 대해 처리하는 로직이 있고, 이를 테스트할 필요가 있다.
* 하지만 제대로 테스트 하지 않으면 리팩터링 내성이 떨어지게 된다.
* 앰비언트 컨텍스트 패턴을 이용해 시간을 직접 설정, 주입하게 되어도 결과는 좋지 않다.
  * 코드가 오염되며, 공유 의존성을 도입해 통합테스트 영역이 되어버린다.
* 가능하면 일반적인 값으로 테스트를 하는게 좋다.
* 일반 값으로 테스트를 진행할수 없을 경우에는, 의존성 주입 시점에서 서비스로 주입 후, 연산에 값으로 전달하는것이 좋다.
  * 즉, 인터페이스를 구축해 활용하는것이 좋다.