# 좋은 단위테스트의 4대 요소

```
* 좋은 단위 테스트의 관점 간 차이점 모색
* 이상적인 테스트 정의
* 테스트 피라미드의 이해
* 블랙박스 테스트 및 화이트박스 테스트 사용
```

## 좋은 단위 테스트의 4대 요소

### 회귀 방지
* 회귀: 코드를 수정 후, 기능이 의도대로 작동하지 않는 경우.
* 회귀방지 지표에 대한 평가
  * 테스트 중 실행되는 코드의 양
    * 일반적으로 코드가 많을수록 회귀가 발생할 가능성이 높다
  * 코드 복잡도
    * 복잡한 비즈니스 로직을 나타내는 코드는 상당히 중요하며, 비즈니스 로직에서 발생하는 버그가 시스템에 가장 큰 피해를 입힌다.
  * 코드의 도메인 유의성

### 리팩터링 내성
* 리팩토링하면서도 테스트에 실패하지 않는지에 대한 척도
* 리팩토링 이후 기능이 작동하나, 테스트의 실패하는 경우 -> 거짓 양성(false positive)
* 구현을 수정하지만, 식별할 수 있는 동작은 유지할때 발생.
* 리팩토링 내성 지표에 대한 평가
  * 얼마나 많은 거짓 양성이 발생하는가?
* 거짓 양성이 안좋은 이유
  * 테스트가 타당한 이유 없이 실패하면, 대응이 희미해지고, 반복되면 익숙해진다.
  * 테스트를 무시하게 될 가능성이 생긴다.
  * 거짓양성이 많아지는데 테스트를 지속적으로 진행할 경우, 리팩토링을 기피하는 가능성이 생긴다.

#### 거짓 양성의 원인?
* 결합이 많아질수록, 복잡해질수록 허위 경보가 더 많이 생긴다.
* 따라서 테스트를 최대한 분리하고, 꼼꼼히 작성하는것이 중요하다.
* 테스트는 최종 사용자 관점에서 SUT를 검증해야 한다.(=블랙박스 테스트?)

#### 구현 세부 사항 대신 최종 결과를 목표로 하기
* 테스트를 실패하지 않게 하고 리팩토링 내성을 높이는 방법은 SUT의 구현 세부사항과 테스트의 결합도를 낮추는 것이다.

### 통계학에 기반을 둔 테스트 표
* <img src="ch4303.png" width="400">
  * 위의 표를 놓고 봤을 때,
  * 테스트를 통과하고 기능도 작동하는것과, 테스트에 실패하고 기능도 고장나는것은 올바른 추론이다.
  * 테스트에는 실패하나 기능은 작동하는것은 거짓 양성이고
  * 테스트에는 통과하나 기능이 고장나는것은 거짓 음성이다.
  * 거짓 음성의 결과가 나오는 것을 방지하는것은 회귀 방지쪽에 가깝고
  * 거짓 양성의 결과가 나오는 것을 방지하는것은 리팩토링 내성에 가깝다.

#### 회귀 방지와 리팩터링 내성간의 본질적 관계
* 리팩토링내성보다는 회귀방지에 집중을 하는것이 좋다.
  * 리팩토링같은경우 초기에는 할 필요가 없기 때문에 상대적으로 덜 중요할 뿐,
  * 시기가 지난 이후에는 비슷하게 신경을 써야한다.
  * 이 때 리팩토링에 대한 내성이 낮다면..(=리팩토링에 소극적이게 된다면)
  * 테스트와 리팩토링 모두 신뢰를 잃어버리게 된다.
    * 여기서 얘기하고자 하는건, 거짓양성이 다수 발견되어 리팩토링에 소극적이게 되는 상황..
* 테스트 정확도 극대화
  * 거짓양성, 거짓음성을 줄여 일단 테스트 정확도를 극대화하는것이 중요하다.
  * 테스트 정확도 = 발견된 버그 수 / 잘못된 테스트(거짓 양성 or 거짓 음성)

### 빠른 피드백
* 테스트는 빠를수록 좋다.
  * 더 많은 테스트를 수행할 수 있고
  * 더 자주 수행할 수 있기 때문에

### 유지보수성
* 테스트를 얼마나 이해하기 어려운가
  * 테스트는 간결하게, 작게 쪼개서 진행하는게 좋다.
    * 인위적은 압축은 금지(라인을 억지로 줄인다던가, 변수를 억지로 짧게 만든다던가 등..)
* 테스트가 얼마나 실행하기 어려운가
  * 외부 종속성을 줄여 의존성을 최대한 낮추는게 좋다.

## 이상적인 테스트?
* 위에서 살펴본 좋은 테스트의 4대 특성
  * 회귀 방지
  * 리팩토링 내성
  * 빠른 피드백
  * 유지보수성
* 네가지의 특성을 곱 해 테스트의 가치를 결정한다.
* 즉 어떤 특성이라도 최소한은 신경을 써줘야 한다. 0이 되면 의미가 없기 때문..
* 하지만 네가지를 모두 극대화 하는것은 불가능하다.
* 회귀방지, 리팩토링 내성, 빠른 피드백 의 세가지 특성은 상호 배타적이기 때문이다.
* 리팩토링 내성을 실제로 포기하기는 힘들기 때문에,
* 회귀 방지(얼마나 버그를 잘 찾아내는지), 빠른 피드백(얼마나 빠른지)사이에서 절충을 하는것이 좋다.
* <img src="ch4304.png" width="400">

## 대중적인 테스트 자동화 개념 살펴보기
* 피라미드는 이전에 정리한것이 있어서 생략.

### 블랙 박스 테스트와 화이트 박스 테스트
* 블랙박스 테스트
  * 시스템의 내부 구조를 모른다는 가정을 하고 진행하는 테스트.
  * 기능확인 > 구현확인
* 화이트박스 테스트
  * 시스템의 내부 구조를 알고 진행하는 테스트.
  * 기능확인 < 구현확인
* 화이트 박스 테스트의 경우 테스트가 깨지기 쉬우며, 거짓 양성을 상대적으로 많이 만들어 낸다.

|테스트|회귀 방지|리팩터링 내성|
|---|---|---|
|화이트박스 테스트|좋음|나쁨|
|블랙박스 테스트|나쁨|좋음|


* 리팩터링 내성을 타협할수는 없다. 따라서 블랙박스 테스트를 기본으로 선택하는것이 좋다.
* 화이트 박스 테스트의 경우, 테스트박스를 분석할 때(코드커버리지를 체크한다던가, 테스트를 점검할때) 사용해볼만하다.

## 정리하며 느낀 점.
* 좋은 테스트에 대한 가치는 객관적으로 판단하기가 힘들기 때문에, 이를 최대한 설명하려는 마음이 느껴졌으나..
* 1, 2장처럼 또 중구난방으로 서술이 된 느낌..
* 참 음성, 거짓 음성, 거짓 양성, 참 양성 등 단어가 생소해서 읽기가 조금 더 어려웠다..
* 예전에도 적었지만, 엔드투엔드 테스트의 경우 프로그래머의 몫이 아니라고 생각 하는데, 테스트를 다루는게 아닌 단위테스트를 다루는 책에서 이게 과연 나올 필요가 있었을까 싶다.
  * 그래도 그나마 엔드투엔드 테스트를 언제 진행할까? 하고 고민해보면.. UI테스트를 할 때?
* 프로그래머의 경우 직접 코드를 작성하는 경우가 많아, 화이트박스 테스트를 진행하게 되는 경향이 있을 것 같은데, 블랙박스테스트의 중요성을 잘 배워가는 것 같다.